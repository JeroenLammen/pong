<canvas id="pongCanvas"></canvas>

<script>

    // RequestAnimFrame: a browser API for getting smooth animations
    window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                window.oRequestAnimationFrame      ||
                window.msRequestAnimationFrame     ||
                function( callback ){
                    return window.setTimeout(callback, 1000 / 60);
                };
    })();

    window.cancelRequestAnimFrame = ( function() {
        return window.cancelAnimationFrame          ||
                window.webkitCancelRequestAnimationFrame    ||
                window.mozCancelRequestAnimationFrame       ||
                window.oCancelRequestAnimationFrame     ||
                window.msCancelRequestAnimationFrame        ||
                clearTimeout
    } )();

    var canvas = $("#pongCanvas")[0];
    var ctx = canvas.getContext("2d");
    var canvasWidth = 800;
    var canvasHeight = 400;
    ctx.canvas.width = canvasWidth;
    ctx.canvas.height = canvasHeight;
    ctx.fillStyle ="#000000";
    var bounce = 1;
    canvas.addEventListener("mousedown", btnClick, true);

    var Paddles = [];

    function Paddle(pos){
        this.width = 10;
        this.height = canvas.height/4;
        this.x = (pos == "left") ? 0 : canvasWidth - this.width;
        this.y = canvasHeight/2 - this.height/2;
        this.draw = function() {
            ctx.fillStyle = "white";
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    };

    var player1 = new Paddle("left");
    var player2 = new Paddle("right");

    Paddles.push(player1);
    Paddles.push(player2);

    function Ball() {
        this.c = "white";
        this.r = 5;
        this.x = canvasWidth / 2;
        this.y = canvasHeight / 2;
        this.vx = 4;
        this.vy = 8;
        this.draw = function() {
            ctx.beginPath();
            ctx.fillStyle = this.c;
            ctx.arc(this.x,this.y,this.r,0,2*Math.PI);
            ctx.fill();
        }
    }

    var ball = new Ball();

//    ball = {
//        r: 5,
//        x: canvasWidth / 2,
//        y: canvasHeight / 2,
//        vx: 4,
//        vy: 8,
//        draw: function() {
//            ctx.fillStyle = "white";
//            ctx.arc(this.x,this.y,this.r,0,2*Math.PI);
//            ctx.fill();
//        }
//    };

    startBtn = {
        w: 100,
        h: 50,
        x: canvasWidth/2 - 50,
        y: canvasHeight/2 - 25,

        draw: function() {
            ctx.strokeStyle = "white";
            ctx.lineWidth = "2";
            ctx.strokeRect(this.x, this.y, this.w, this.h);

            ctx.font = "18px Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStlye = "white";
            ctx.fillText("Start", canvasWidth/2, canvasHeight/2 );
        }
    };

    function startScreen() {
        draw();
        startBtn.draw();

    }

    function animloop() {
        init = requestAnimFrame(animloop);
        draw();
    }

    function draw() {
        paintCanvas();
        for (var p = 0; p < Paddles.length; p++) {
            Paddles[p].draw();
        }
        ball.draw();
        update();
    }

    function paintCanvas() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    function update() {
        ball.x += ball.vx;
        ball.y += ball.vy;
        //console.log("bounce: " + bounce);
        console.log("ball.vx = " + ball.vx + ", ball.vy = " + ball.vy);

        p1 = Paddles[0];
        p2 = Paddles[1];

        if(collides(ball, p1)) {
            bounce++;
            collideWithPaddle(ball, p1);
        }


        else if(collides(ball, p2)) {
            bounce++;
            collideWithPaddle(ball, p2);
        }

        collideWithWall();
    }

    function collides(b, p) {
        if(b.y + ball.r >= p.y && b.y - ball.r <=p.y + p.height) {
            if(b.x >= (p.x - p.width) && p.x > 0){
                return true;
            }

            else if(b.x <= p.width && p.x == 0) {
                return true;
            }

            else return false;
        }
    }

    function collideWithPaddle(ball, p) {
        bounce++;
        ball.vx = -ball.vx;
       // increaseSpd();
    }

    function collideWithWall() {
        // If ball strikes the vertical walls, invert the
        // x-velocity vector of ball
        if(ball.y + ball.r > canvasHeight) {
            ball.vy = -ball.vy;
            ball.y = canvasHeight - ball.r;
            bounce++;
        }

        else if(ball.y -ball.r < 0) {
            ball.vy = -ball.vy;
            ball.y = ball.r;
            bounce++;
        }


       // increaseSpd();
    }

    function increaseSpd() {
        if(bounce % 10 == 0) {
            bounce++;
            if(Math.abs(ball.vx) < 15) {
                ball.vx += (ball.vx < 0) ? -1 : 1;
                ball.vy += (ball.vy < 0) ? -2 : 2;
            }
        }
    }

    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    // On button click (Restart and start)
    function btnClick(e) {

        var pos = getMousePos(canvas, e);

        // Click start button
        if(pos.x >= startBtn.x && pos.x <= startBtn.x + startBtn.w && pos.y >= startBtn.y && pos.y <= startBtn.y + startBtn.h) {
            startBtn = {};
            animloop();
        }
    }

    var socket = io();
    socket.on("movePaddle", function(motionData) {
        console.log(motionData.beta);
        Paddles[0].y = map(motionData.beta, 0,90,0,canvasHeight-Paddles[0].height);
        //animloop();
    });

    function map( x,  in_min,  in_max,  out_min,  out_max){
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

    startScreen();

</script>